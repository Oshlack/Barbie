#' differential proportion test on Barcodes across sample groups
#'
#' @param Barbie a Barbie object created by createBarbie()
#' @param mycontrasts a contast matrix generated by limma::makeContrasts
#' @param contrastLevels a charactor vector indicating the levels in specified groupBy
#' @param designMatrix a numeric matrix indicating sample conditions
#' @param block a vector of indicating sample duplicates
#'
#' @import limma
#' @import magrittr
#'
#' @return an updated Barbie object storing test results
#'
#' @examples
#' Barbie <- testDiffProp(Barbie = Barbie, mycontrasts = mycontrasts,
#'                        contrastLevels = contrastLevels, designMatrix = designMatrix,
#'                        block = block)
testDiffProp <- function(Barbie, mycontrasts=NULL, contrastLevels=NULL,
                         designMatrix=NULL, block=NULL) {
  if(is.null(rownames(Barbie$proportion)))
    rownames(Barbie$proportion) <- rownames(Barbie$assay)
  if(is.null(rownames(Barbie$proportion)))
    rownames(Barbie$proportion) <- paste0("barcode", seq(nrow(Barbie$proportion)))
  ## arcsin square root transformation for proportion data
  mydata <- Barbie$proportion %>% sqrt() %>% asin()
  message("testing Barbie$proportion after arcsin square root transformation.")
  if(!is.null(block)) {
    ## compute duplicates correction
    dup <- limma::duplicateCorrelation(object = mydata, design = designMatrix,
                                       block = block)
    message("Consensus correlation of Barcode proportion within sample duplicates: ",
            dup$consensus.correlation)
    ## fit limma linear regression model taking duplicates
    myfit1 <- limma::lmFit(object = mydata, design = designMatrix,
                           block = block, correlation = dup$consensus.correlation)
  } else {
    ## ignore duplicates
    message("the block argument specifies which samples are duplicates.
             no block specified, so there are no duplicate measurements.")
    ## fit limma linear regression model without duplicates
    myfit1 <- limma::lmFit(object = mydata, design = designMatrix)
  }
  ## fit contrast
  myfit2 <- limma::contrasts.fit(fit = myfit1, contrasts = mycontrasts)
  ## fit eBayes, moderated p.values obtained after applying empirical Bayes
  myfit3 <- limma::eBayes(myfit2)
  ## extract test result using multiple testing adjusted p.values
  myresults <- limma::decideTests(myfit3, adjust.method = "BH")
  direction <- dplyr::recode(as.vector(myresults), "1"=contrastLevels[2],
                             "-1"=contrastLevels[1], "0" = "n.s.")
  names(direction) <- rownames(myresults)
  Barbie$BarcodeBiasProp <- data.frame(direction = direction)
  ## extract adjusted p.values adjusted for multiple testing
  ## setting number to Inf will retain all Barcodes
  rankedResults <- limma::topTable(myfit3, number=Inf)
  adjustedPvalues <- rankedResults[rownames(Barbie$BarcodeBiasProp),]$adj.P.Val
  Barbie$BarcodeBiasProp <- cbind(Barbie$BarcodeBiasProp, p.value = adjustedPvalues)

  return(Barbie)
}
