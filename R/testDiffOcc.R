# @import logistf
# Barbie <- testDiffOcc(Barbie = Barbie, mycontrasts = mycontrasts,
#                        contrastLevels = contrastLevels, designMatrix = designMatrix,
#                        block = block)
#' differential occurrence test on Barcodes across sample groups
#'
#' @param Barbie a Barbie object created by createBarbie()
#' @param regularization a string, options: "firth" and "none", choosing regularization method
#' @param mycontrasts a contast matrix generated by limma::makeContrasts
#' @param contrastLevels a charactor vector indicating the levels in specified groupBy
#' @param designMatrix a numeric matrix indicating sample conditions
#'
#' @import logistf
#' @import magrittr
#'
#' @return an updated Barbie object storing test results
#'
#' @examples
#' Barbie <- testDiffOcc(Barbie, regularization="firth",
#' mycontrasts = mycontrasts, contrastLevels = contrastLevels,
#' designMatrix = designMatrix)
testDiffOcc <- function(Barbie, regularization="firth",
                        mycontrasts = mycontrasts, contrastLevels = contrastLevels,
                        designMatrix = designMatrix) {
  ## check 'regularization'
  regularization <- match.arg(regularization, c("firth", "none"))
  ## extract binary data
  outcome <- Barbie$occurrence +1 -1
  ## regenerate designMatrix based on the mycontrasts specified
  ## identify variables based on contrast rules
  interceptVar <- rownames(mycontrasts)[mycontrasts == -1]  # Intercept could be charactor(0)
  primaryVar <- rownames(mycontrasts)[mycontrasts == 1]  # First Predictor
  additionalVar <- rownames(mycontrasts)[mycontrasts == 0]  # Other predictors
  ## recreate the formula
  formulaStr <- paste0(primaryVar)
  if (length(additionalVar) > 0) {
    formulaStr <- paste0(formulaStr, " + ", paste(additionalVar, collapse = " + "))
  }
  ## recreate design without the intercept (interceptVar serves as reference)
  formulaStr <- paste0("~ ", formulaStr, " - 1")
  formula <- as.formula(formulaStr)
  design <- model.matrix(formula, data = data.frame(designMatrix))

  ## case when "none" regularization, fit classic model
  if(regularization == "none"){
    results <- lapply(1:nrow(outcome), function(i)
      glm(outcome[i,] ~ design,
          family = "binomial") %>% summary())
    ## extract stats
    tag <- paste0("design", primaryVar)
    pvalues <- lapply(results, function(x)
      x$coefficients[tag,"Pr(>|z|)"]) %>% unlist()
    beta <- lapply(results, function(x)
      x$coefficients[tag,"Estimate"]) %>% unlist()
    ## extract stats result sheet
    statMat <- data.frame(pvalues = pvalues, beta = beta)
  } else if(regularization == "firth"){
    ## case when "firth" regularization, fit penalized logistic model
    results <- lapply(1:nrow(outcome), function(i)
        invisible(logistf(outcome[i, ] ~ design)))
    tag <- paste0("design", primaryVar)
    ## extract stats
    pvalues <- lapply(results, function(x)
      x$prob[tag]) %>% unlist()
    beta <- lapply(results, function(x)
        x$coefficients[tag]) %>% unlist()
    ## extract stats result sheet
    statMat <- data.frame(pvalues = pvalues, beta = beta)
  }
  ## compute adjusted p.values
  statMat$pvalues <- p.adjust(statMat$pvalues, method = "BH")
  ## decide direction
  direction <- ifelse(statMat$pvalues >= 0.05, "n.s.",
                      ifelse(statMat$beta > 0, contrastLevels[2],
                             contrastLevels[1]))

  Barbie$BarcodeBiasOcc <- data.frame(direction=direction,
                                      p.value=statMat$pvalues)

  return(Barbie)
}
