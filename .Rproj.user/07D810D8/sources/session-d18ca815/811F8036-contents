#' Test Barcodes bias across sample groups
#'
#' @param Barbie a Barbie object created by createBarbie()
#' @param method a string, options: "diffProp" and "diffOcc", choosing test method
#' @param targets a matrix or data.frame storing sample conditions
#' @param sampleGroups a string, or a vector of sample conditions indicating the primary effector to be tested
#' @param contrastLevels a charactor vector indicating the levels in specified 'sampleGroups'
#' @param designFormula a formula to compute the designMatrix
#' @param designMatrix a numaric matrix to standardize 'targets'
#' @param block a vector of indicating sample duplicates
#' @param transformation a string, choosing transformation method in "diffProp" test
#' @param regularization a string, options: "firth" and "none", choosing regularization method in "diffOcc" test
#'
#' @return an updated Barbie object storing test results
#' @export
#'
#' @import limma
#' @importFrom magrittr %>%
#' @import logistf
#' @import stats
#' @examples
#' Block <- c(1,1,2,3,3,4,1,1,2,3,3,4)
#' Treat <- factor(rep(1:2, each=6))
#' Time <- rep(rep(1:2, each=3), 2)
#' nbarcodes <- 50
#' nsamples <- 12
#' count <- matrix(rnorm(nbarcodes*nsamples), nbarcodes, nsamples) %>% abs()
#' rownames(count) <- paste0("Barcode", 1:nbarcodes)
#' Barbie <- Barbie::createBarbie(count, data.frame(Treat=Treat, Time=Time))
#' testBarcodeBias(Barbie, groupBy = "Treat")
testBarcodeBias <- function(Barbie, method="diffProp",
                            targets=NULL, sampleGroups=NULL, contrastLevels=NULL,
                            designFormula=NULL, designMatrix=NULL,
                            block=NULL,
                            transformation="asin-sqrt", regularization="firth"){
  ## check Barbie dimensions
  if(!checkBarbieDimensions(Barbie))
    stop("Barbie components are not in right format or dimensions don't match.
         use createBarbie() and other functions in the 'Barbie' package to modify the object and don't do it manually.")
  ## check method: confirm method is chosen from "diffProp" and "diffOcc"
  method <- match.arg(method, c("diffProp", "diffOcc"))
  ## extract targets and primary effector based on arguments
  targetsInfo <- extarctTargetsAndPrimaryFactor(Barbie = Barbie, targets = targets, sampleGroups = sampleGroups)
  mytargets <- targetsInfo$mytargets
  pointer <- targetsInfo$pointer
  ## extract the groupTitle to be compared: sampleGroups
  groupTitle <- colnames(mytargets)[pointer]
  ## confirm all effectors (columns) in 'mytargets' are factor() or numeric()
  ## convert columns that are neither factor nor numeric into factor
  nonFac <- sapply(mytargets, function(x) !(is.factor(x) | is.numeric(x)))
  for(col in seq(nonFac)[nonFac]) {
    mytargets[,col] <- factor(mytargets[,col])
  }
  ## remove factor columns with only one level - will be problematic in model.matrix
  oneLevelFactors <- sapply(mytargets, function(x) is.factor(x) && length(unique(x)) == 1)
  if(any(oneLevelFactors)) {
    mytargets <- mytargets[, !oneLevelFactors]
    message("removing effectors with only one level from targets: ",
            paste0(colnames(mytargets)[oneLevelFactors], collapse = ", "))
  }

  ## import 'design' using tidy evaluation
  ## if designFormula not specified, taking all effectors from 'mytargets' into account
  ## prioritize the column of sampleGroups to be compared
  if (is.null(designFormula)) {
    designFormula <- paste("~0 + ",
                           paste(groupTitle, paste0("+ ", setdiff(colnames(mytargets), groupTitle), collapse = " "))) %>%
      as.formula()
  }
  ## check designFormula format
  if (!inherits(designFormula, "formula")) {
    stop("The 'designFormula' argument must be a valid formula.")
  } else {
    ## check if all variables in designFormula are present in 'mytargets'
    missingTerms <- setdiff(all.vars(designFormula), colnames(mytargets))
    if (length(missingTerms) > 0) {
      stop("The following variables in the 'designFormula' are missing from 'targets' or 'Barbie$metadata':",
           paste(missingTerms, collapse = ", "))
      }
    }

  ## if designMatrix not specified, generate it by designFormula
  if (is.null(designMatrix)) {
    designMatrix <- model.matrix(designFormula, data=mytargets)
  } else {
    ## check designMatrix format and dimension
    if (is.matrix(designMatrix) || is.data.frame(designMatrix)) {
      if (nrow(designMatrix) != nrow(mytargets)) {
        stop("row dimension of 'designMatrix' doean't match row dimension of 'targets' or 'Barbie$metadata'.")
      }
    } else {
      stop("'designMatrix' should always be a matrix.
           use fucntion model.matrix() to generate a 'designMatrix'.")
    }
    }

  ## make designMatrix full rank by deleting columns of nested effectors, ie. linearly related vectors
  ## compute QR decomposition of the designMatrix
  q <- qr(designMatrix)
  keep <- rep(TRUE, ncol(designMatrix))
  ## select the indices in the pivot vector after the rank of the matrix
  ## the columns of matrix that are linearly dependent (those that do not contribute to the rank)
  keep[q$pivot[-seq(q$rank)]] <- FALSE
  designMatrix <- designMatrix[,keep, drop=FALSE]
  ## message the users if any linearly related vectors are deleted
  if(any(!keep))
    message(sum(!keep), " nested effector(s) in the designMatrix were deleted because designMatrix must be full rank.")

  ## check block groups if it's specified
  if(!(is.null(block))) {
    if(length(block) != ncol(Barbie$assay))
      stop("the length of 'block' doesn't match the row dimention (sample size) of specified 'targets' or 'Barbie$metadata'.")
  }

  ## 'pointer' indicates which column relates to 'sampleGroups': either a imported 'sampleGroups' column or a column name specified by 'sampleGroups' like 'Treat'
  ## case when sampleGroups column is factor
  if(is.factor(mytargets[, pointer])) {
    ## make group contrast, extract levels if not specified
    if(is.null(contrastLevels)) {
      contrastLevels <- levels(mytargets[, pointer])
    } else if (is.vector(contrastLevels)){
      missingLevels <- setdiff(contrastLevels, levels(mytargets[, pointer]))
      if(length(missingLevels) > 0) {
        stop("'contrastLevels' constains levels: ", missingLevels, " missing from the 'sampleGroups' column in 'targets' or 'Barbie$metadata'.")
      }
    } else {
      stop("'contrastLevels' argument should be a vector indicating levels in the 'sampleGroups' column in 'targets' or 'Barbie$metadata'.")
    }

    ## now 'contrastLevels' should be a vector indicating levels in the 'sampleGroups' column
    ## 'contrastLevels' has one, two, or several levels.
    if(length(contrastLevels) == 2L) {
      ## create contrast for the first two levels of 'sampleGroups'
      contrastFormula <- paste0(groupTitle, contrastLevels[2], " - ", groupTitle, contrastLevels[1])
      ## generate contrast for designMatrix
      mycontrasts <- limma::makeContrasts(contrasts = contrastFormula,
                                          levels = colnames(designMatrix))
    } else {
      stop("'contrastLevels' has ", length(contrastLevels), " level(s), it should contain two levels for the 'sampleGroups' factor in 'targets' or 'Barbie$metadata'.")
    }

  } else if(is.numeric(mytargets[, pointer])) {
    ## case when sampleGroups column is numeric
    ## generate contrast for designMatrix
    mycontrasts <- limma::makeContrasts(contrasts = groupTitle,
                                        levels = colnames(designMatrix))
    contrastLevels <- c("decrease", "increase")
  }

  ## store test information
  testMethods <- list(
    aim = "",
    formula = designFormula,
    method = "",
    transformation = "",
    regularization = "",
    adjusted.p.value = "Benjamini-Hochberg false discovery rate",
    contrastVector = groupTitle,
    contrastLevels = contrastLevels
  )

  ## all test results will be saved in Barbie$testBarcodes
  if(is.null(Barbie$testBarcodes)) Barbie$testBarcodes <- list()

  ## dispatch test functions based on the specified method
  ## default setting is "diffProp"
  if(method == "diffProp") {
    BarcodeBiasProp <- testDiffProp(
      Barbie = Barbie, transformation = transformation,
      mycontrasts = mycontrasts, contrastLevels = contrastLevels,
      designMatrix = designMatrix, block = block
      )
    ## clarify test methods information
    testMethods$aim <- "testing differential proportion"
    testMethods$method <- "linear regression"
    testMethods$transformation <- transformation
    ## store test results and methods
    elementName <- paste0("diffProp_", groupTitle)
    if(!is.null(Barbie$testBarcodes[[elementName]]))
      message("overwriting exsiting test results")
    Barbie$testBarcodes[[elementName]] <- list(results = BarcodeBiasProp,
                                               methods = testMethods,
                                               targets = mytargets)
  } else if(method == "diffOcc") {
    ## logistic regression, default regularization is "firth"
    BarcodeBiasOcc <- testDiffOcc(
      Barbie, regularization = regularization,
      mycontrasts = mycontrasts, contrastLevels = contrastLevels,
      designMatrix = designMatrix
      )
    ## clarify test methods information
    testMethods$aim <- "testing differential occurrence"
    testMethods$method <- "logistic regression"
    testMethods$regularization <- regularization
    ## store test results and methods
    elementName <- paste0("diffOcc_", groupTitle)
    if(!is.null(Barbie$testBarcodes[[elementName]]))
      message("overwriting exsiting test results")
    Barbie$testBarcodes[[elementName]] <- list(results = BarcodeBiasOcc,
                                               methods = testMethods,
                                               targets = mytargets)
  } else {stop("please choose test method from 'diffProp' or 'diffOcc'.")}

  ## assign colors for the test results
  if(is.null(Barbie$factorColors[[elementName]])) {
    Barbie$factorColors[[elementName]] <- setNames(
      c("#33AAFF", "#FF5959", "#FFC000"),
      c(contrastLevels[1], contrastLevels[2], "n.s."))
  }

  print(testMethods)

  ## visualize test results by Heatmap and dotplots

  return(Barbie)
}
