#' differential proportion test on Barcodes across sample groups
#'
#' @param Barbie a Barbie object created by createBarbie()
#' @param transformation a string, choosing transformation method in "diffProp" test
#' @param mycontrasts a numeric vector generated by limma::makeContrasts
#' @param contrastLevels a character vector indicating the levels of the conditions in specified factor effector (primary predictor), note the conditions must be strings
#' @param designMatrix a numeric matrix indicating sample conditions
#' @param block a vector indicating sample duplicates
#'
#' @import limma
#' @importFrom magrittr %>%
#'
#' @return an updated Barbie object storing test results
#'
#' @examples
#' Block <- c(1,1,2,3,3,4,1,1,2,3,3,4)
#' Treat <- factor(rep(c("ctrl", "drug"), each=6))
#' Time <- rep(rep(1:2, each=3), 2)
#' nbarcodes <- 50
#' nsamples <- 12
#' count <- matrix(rnorm(nbarcodes*nsamples), nbarcodes, nsamples) %>% abs()
#' rownames(count) <- paste0("Barcode", 1:nbarcodes)
#' Barbie <- Barbie::createBarbie(count, data.frame(Treat=Treat, Time=Time))
#' testDiffProp(
#'   Barbie = Barbie,
#'   mycontrasts = c(-1, 1, 0),
#'   contrastLevels = c("ctrl", "drug"),
#'   designMatrix = model.matrix(~0 + Treat + Time))
testDiffProp <- function(Barbie, transformation="asin-sqrt",
                         mycontrasts=NULL, contrastLevels=NULL,
                         designMatrix=NULL, block=NULL) {
  if(is.null(rownames(Barbie$proportion)))
    rownames(Barbie$proportion) <- rownames(Barbie$assay)
  if(is.null(rownames(Barbie$proportion)))
    rownames(Barbie$proportion) <- paste0("barcode", seq(nrow(Barbie$proportion)))
  ## checking transformation
  transformation <- match.arg(transformation, c("asin-sqrt", "logit", "none"))
  ## arcsin square root transformation for proportion data
  mydata <- Barbie$proportion %>% sqrt() %>% asin()
  message("testing Barbie$proportion after arcsin square root transformation.")
  if(!is.null(block)) {
    ## compute duplicates correction
    dup <- limma::duplicateCorrelation(object = mydata, design = designMatrix,
                                       block = block)
    message("Consensus correlation of Barcode proportion within sample duplicates: ",
            dup$consensus.correlation)
    ## fit limma linear regression model taking duplicates
    myfit1 <- limma::lmFit(object = mydata, design = designMatrix,
                           block = block, correlation = dup$consensus.correlation)
  } else {
    ## ignore duplicates
    message("no block specified, so there are no duplicate measurements.")
    ## fit limma linear regression model without duplicates
    myfit1 <- limma::lmFit(object = mydata, design = designMatrix)
  }
  ## fit contrast
  myfit2 <- limma::contrasts.fit(fit = myfit1, contrasts = mycontrasts)
  ## fit eBayes, moderated p.values obtained after applying empirical Bayes
  myfit3 <- limma::eBayes(myfit2)
  ## extract test result using multiple testing adjusted p.values
  myresults <- limma::decideTests(myfit3, adjust.method = "BH")
  direction <- dplyr::recode(as.vector(myresults), "1"=contrastLevels[2],
                             "-1"=contrastLevels[1], "0" = "n.s.")
  names(direction) <- rownames(myresults)
  ## extract adjusted p.values adjusted for multiple testing
  ## setting number to Inf will retain all Barcodes
  ## setting sort.by to "none" will stop sorting Barcodes by p.values
  rankedResults <- limma::topTable(myfit3, number=Inf, sort.by = "none")
  reorderedResults <- rankedResults[names(direction),]

  BarcodeBiasProp <- data.frame(
    direction = direction,
    adj.p.value = reorderedResults$adj.P.Val,
    p.value = reorderedResults$P.Value,
    logFC = reorderedResults$logFC,
    t = reorderedResults$t
    )

  message("logFC is based on the data being tested, after being transformed.")

  return(BarcodeBiasProp)
}
